## 前端小测

### 1. 全局函数有哪些

| 全局函数              | 作用                                             |
| --------------------- | ------------------------------------------------ |
| decodeURI( )          | 解码某个编码的URI                                |
| decodeURIComponent( ) | 解码一个编码的 URI 组件                          |
| encodeURI( )          | 把字符串编码为 URI                               |
| encodeURIComponent( ) | 把字符串编码为 URI 组件                          |
| escape( )             | 对字符串进行编码                                 |
| eval( )               | 计算 JavaScript 字符串，并把它作为脚本代码来执行 |
| isFinite( )           | 检查某个值是否为有穷大的数                       |
| inNaN( )              | 检查某个值是否是数字                             |
| Number( )             | 检查某个值是否是数字                             |
| parseInt( )           | 解析一个字符串并返回一个整数                     |
| parseFloat( )         | 解析一个字符串并返回一个浮点数                   |
| String( )             | 把对象的值转换为字符串                           |
| unescape( )           | 对由 escape() 编码的字符串进行解码               |

### 2. 继承的几种方式，有什么区别

6种，区别如图：

![不多说直接上图](https://static.vue-js.com/0df74700-731c-11eb-ab90-d9ae814b240d.png)

### 3. 创建对象的几种方式，谈谈理解

一、使用对象字面量的方式{}

`var person ={`
    `name: "zs",`
    `age: 21,`
    `family: ["lisi","lisa","wangwu"],`
`}`

二、使用Object 关键字方式来创建 （工厂模式）

``var wcDog = new Object();` 
	`wcDog.name="旺财";` 
	`	wcDog.age=3;` 

​	`	wcDog.work();`

三、用构造函数来创建：可以使用有参构造函数来实现，这样定义更方便，扩展性更强

`function QGer(name,age,hobby){ 
	this.name=name;//this 作用域：当前对象
	this.age=age; 
	this.hobby=hobby; }
	var maidou =new QGer("zhuoran",20,"睡觉"); // 实例化/创建对象`

四、使用原型对象的方式 （prototype 关键字）： 原型模式的好处是所有对象实例共享它的属性和方法（即所谓的共有属性）还可以设置自己的属性（方法），可以覆盖原型对象上的同名属性（方法）

五、混合模式(原型和构造函数) ：构造函数模式用于定义实例属性，原型模式用于定义方法和共享的属性

### 4. new创建对象时做了些什么

1、创建一个新对象，如：var person = {};

2、新对象的_proto_属性指向构造函数的原型对象。

3、将构造函数的作用域赋值给新对象。（也所以this对象指向新对象）

4、执行构造函数内部的代码，将属性添加给person中的this对象。

5、返回新对象person。

### 5. 闭包是什么，有什么作用和缺点

一个定义在函数内部的函数，可以读取到其他函数内部变量的函数，本质上，闭包就是一个把函数内部和外部连接起来的桥梁。简单来说就是指有权访问另外一个函数作用域中的变量的函数（闭包就是能够读取其他函数内部变量的函数）

作用：函数内部定义的变量属于局部变量，当局部变量所在的函数被调用的时候，就开始执行，当调用执行一旦结束，局部变量就会被释放，当我们需要函数内部变量时，他已经被释放了，读取不到了，这个时候我们就可以用闭包，延长局部变量的执行时间，当函数执行完毕以后，局部变量不可以被内存释放，然后让外部可以访问到这个变量。

缺点：

闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，可能会导致内存泄露

闭包会在父函数外部，改变父函数内部变量的值。



### 6. this的指向有哪些

1、普通函数中的this指向window

2、定时器中的this指向window

3、箭头函数没有this,它的this指向取决于外部环境、指向最近的的函数

4、事件中的this指向事件的调用者

5、 构造函数中this和原型对象中的this,都是指向构造函数new 出来实例对象

6、类 class中的this 指向由constructor构造器new出来的实例对象

7、自调用函数中的this 指向window



### 7. 类和构造函数的区别

1.类的内部所有定义的方法，都是不可枚举的（但是在es5中prototype的方法是可以进行枚举的）

2.类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行

3.Class不存在变量提升（hoist），这一点与ES5完全不同

4.ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。



### 8. apply、call、bind的区别？

1.三者都可以改变函数的this指向

2.三者第一个参数都是this要指向的对象，如果没有这个参数或参数为undefined或null，默认指向是全局window

3.三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，bind可以分为多次传入

4.bind是返回绑定this之后的函数，便于稍后调用；apply、call则是立即执行



### 9. 关于事件循环

说说以下代码执行结果，并给出解释：

```js
console.log(1);//同
setTimeout(function(){
    console.log(2);//异宏
},0)

new Promise(function(resolve,reject){
    console.log(3)//同
    resolve();
    setTimeout(function(){
        console.log(4);//异宏
    },0);
}).then(res=>{
    console.log(5);//异微
})
console.log(6);//同
```

这题涉及了同步与异步，宏任务与微任务的知识点

每次任务先执行完同步，再执行异步

宏任务：当前调用栈中执行的代码成为宏任务。 （主代码，定时器等等）。

微任务： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务,可以理解为回调事件。

每次执行宏任务后，都要检查是否有微任务，有的话要完成所有微任务，没有的话则进行下一个宏任务

**同步操作（由上到下）：**

`1 //console.log(1)` 

`3 //console.log(3)`

`6 //console.log(6)`

**异步操作:**（setTimeout是宏任务，Promise是微任务）

微任务then方法先执行：

`5 //console.log(5)`

两个0s计时器函数按进队先后顺序在队列执行：

`2 //console.log(2)`

`4 //console.log(4)`



### 10.一个随机整数组，将所有大于0的值相加。进阶：两句以内。

例：[-1, 3, 2, 0] => 5

`console.log(eval(...array.filter((item) => item > 0).join("+")));`



### 11.原型和原型链是什么？显示原型和隐式原型的区别？原型链的作用？

原型：JS声明构造函数(用来实例化对象的函数)时，会在内存中创建一个对应的对象，这个对象就是原函数的原型。

原型链：当在实例化的对象中访问一个属性时，首先会在该对象内部(自身属性)寻找，如找不到，则会向其__proto__指向的原型中寻找，如仍找不到，则继续向原型中__proto__指向的上级原型中寻找，直至找到或Object.prototype.__proto__为止（值为null），这种链状过程即为原型链。

显示原型和隐式原型的区别：

prototype 每一个函数在创建之后，便会拥有一个prototype属性，这个属性指向函数的原型对象，显示原型的作用是用来实现基于原型的继承与属性的共享

__proto__上面说的这个原型是JavaScript中的内置属性prototype，此属性继承自object对象，但Firefox、Safari和Chrome在每个对象上都支持一个属性_proto，隐式原型的作用是用来构成原型链，实现基于原型的继承



### 12.作用域链和执行上下文的区别是什么？他们分别的作用是什么？

区别：

1.全局作用域 之外，每个函数都会创建自己的作用域，作用域链在函数定义时就已经确定了。 而不是在函数调用时 

全局执行上下文环境是在全局作用域确定之后, js代码马上执行之前创建 

函数执行上下文是在调用函数时, 函数体代码执行之前创建

2.作用域链是静态的, 只要函数定义好了就一直存在, 且不会再变化 

执行上下文是动态的, 调用函数时创建, 函数调用结束时就会自动释放

作用：

1.作用域的集合就是作用域链，决定了哪些数据能被函数的访问
函数在执行的过程中，先从自己内部寻找变量
如果找不到，再从创建当前函数所在的作用域去找，从此往上，也就是向上一级找。

2.执行上下文栈的作用是用来跟踪代码的，由于JS是单线程的，每次只能做一件事情，其他的事情会放在指定的上下文栈中排队等待执行。

JS解释器在初始化代码的时候，首先会创建一个新的全局执行上下文到执行上下文栈顶中，然后随着每次函数的调用都会创建一个新的执行上下文放入到栈顶中，随着函数执行完毕后被执行上下文栈顶弹出，直到回到全局的执行上下文中。



### 13.Function构造函数的显示原型和隐式原型是什么？两者有什么关系？

方法(Function)是对象，方法的原型（Function.prototype）是对象（Object），对象具有属性（__proto__）称为隐式原型，（**关系：**Function除了和其他对象一样具有__proto__属性以外，它还有一个自己特有的原型属性(prototype)，这个属性是一个指针，指向原型对象。原型对象也有一个属性叫constructor，这个属性包含一个指针，指向原构造函数。



## **送分题：**

### **14.编写一段代码实现一个数组方法，使任何数组都可以调用 `array.last()` 方法，这个方法将返回数组最后一个元素。如果数组中没有元素，则返回 `-1` 。**

`Array.prototype.last = ( ) => this[this.length-1] ?? -1`

### **15.请你编写一个名为 `createHelloWorld` 的函数。它应该返回一个新的函数，该函数总是返回 `"Hello World"`** 

例如：

**输入：args = []**                                                                                          
**输出："Hello World"**
**解释：**
**const f = createHelloWorld();**
**f(); // "Hello World"**

***createHelloWorld 返回的函数应始终返回 "Hello World"。****



`const createHelloWorld = ()=>()=>console.log("Hello World")`



**输入：args = [{},null,42]**
**输出："Hello World"**
**解释：**
**const f = createHelloWorld();**
**f({}, null, 42); // "Hello World"**

**可以传递任何参数给函数，但它应始终返回 "Hello World"。**

``const createHelloWorld = (...args:any)=>()=>console.log("Hello World")`





